// //Метки

// outer: for (let i = 0; i < 3; i++) {

//   for (let j = 0; j < 3; j++) {

//     let input = prompt(`Значение на координатах (${i},${j})`, '');

//     // если пустая строка или Отмена, то выйти из обоих циклов
//     if (!input) break outer; // (*)

//     // сделать что-нибудь со значениями...
//   }
// }

// alert('Готово!');

// //В данном случае мы выходим на метку из двух циклов и переходим в конец помеченного цикла (ситуативно, но супер удобно)

// //Tasks
// let i = 3;

// while (i) {
//   alert( i-- ); //1
// }
// //1
// let i1 = 0;
// while (++i1 < 5) alert( i1 ); // 4

// let i2 = 0;
// while (i2++ < 5) alert( i2 ); // 5
// //2
// for (let i = 0; i < 5; i++) alert( i ); //4

// for (let i = 0; i < 5; ++i) alert( i ); //4

// /*

// Такой результат обусловлен алгоритмом работы for:

// Выполнить единожды присваивание i = 0 перед чем-либо (начало).
// Проверить условие i < 5
// Если true – выполнить тело цикла alert(i), и затем i++
// Увеличение i++ выполняется отдельно от проверки условия (2), значение i при этом не используется, поэтому нет никакой разницы между i++ и ++i.

// */
// //3
// for (let i = 2; i <= 10; i++) {
//     if (i % 2 === 0) {
//         alert(i)
//     }
// }
// //4
// let i0 = 0;

// while(i0 < 3) {
//     alert(`number ${i0}!`);
//     i0++;
// }
// //5
// let numVal;
// do {
//     numVal = prompt('Введите число:', '');    
// } while(numVal <=100 && numVal);

//6
let n = 10;

nextPrime:
for (let i = 2; i <= n; i++) { // Для всех i...

  for (let j = 2; j < i; j++) { // проверить, делится ли число..
    if (i % j == 0) continue nextPrime; // не подходит, берём следующее
  }

  alert( i ); // простое число
}