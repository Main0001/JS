/*
Символы гарантированно уникальны. 
Даже если мы создадим множество символов с одинаковым описанием, 
это всё равно будут разные символы. Описание – это просто метка, 
которая ни на что не влияет.

Например, вот два символа с одинаковым описанием – но они не равны:
*/

let id3 = Symbol("id");
let id4 = Symbol("id");

alert(id3 == id4); // false

let id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает
//Symbol не преобразуются автоматически в строки

// Символы позволяют создавать «скрытые» свойства объектов, 
// к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.

// Например, мы работаем с объектами user, которые принадлежат стороннему коду. Мы хотим добавить к ним идентификаторы.

// Используем для этого символьный ключ:

let user = {
  name: "Вася"
};

let id1 = Symbol("id");

user[id1] = 1;

alert( user[id1] ); // мы можем получить доступ к данным по ключу-символу
// Почему же лучше использовать Symbol("id"), а не строку "id"?

// Так как объект user принадлежит стороннему коду, и этот код также работает с ним, 
// то нам не следует добавлять к нему какие-либо поля. Это небезопасно. 
// Но к символу сложно нечаянно обратиться, сторонний код вряд ли его вообще увидит, и, 
// скорее всего, добавление поля к объекту не вызовет никаких проблем.

// читаем символ из глобального реестра и записываем его в переменную
id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true

//глобальные символы

// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
