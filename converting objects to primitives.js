// Как JavaScript решает, какое преобразование применить?

// Существует три варианта преобразования типов, 
// которые происходят в различных ситуациях. Они называются «хинтами», как описано в спецификации:

// "string"
// Для преобразования объекта к строке, когда мы выполняем операцию над объектом, которая ожидает строку, например alert:

// // вывод
// alert(obj);

// // используем объект в качестве ключа
// anotherObj[obj] = 123;
// "number"
// Для преобразования объекта к числу, в случае математических операций:

// // явное преобразование
// let num = Number(obj);

// // математические (не считая бинарного плюса)
// let n = +obj; // унарный плюс
// let delta = date1 - date2;

// // сравнения больше/меньше
// let greater = user1 > user2;
// Большинство встроенных математических функций также включают в себя такое преобразование.

// "default"
// Происходит редко, когда оператор «не уверен», какой тип ожидать.

// Например, бинарный плюс + может работать как со строками (объединяя их в одну), так и с числами (складывая их). Поэтому, если бинарный плюс получает объект в качестве аргумента, он использует хинт "default" для его преобразования.

// Также, если объект сравнивается с помощью == со строкой, числом или символом, тоже неясно, какое преобразование следует выполнить, поэтому используется хинт "default".

// // бинарный плюс использует хинт "default"
// let total = obj1 + obj2;

// // obj == number использует хинт "default"
// if (user == 1) { ... };
// Операторы сравнения больше/меньше, такие как < >, также могут работать как со строками, 
// так и с числами. Тем не менее, по историческим причинам, они используют хинт "number", а не "default".

// Все встроенные объекты, за исключением одного (объект Date, который мы рассмотрим позже), \
// реализуют "default" преобразование тем же способом, что и "number". И нам следует поступать так же.

obj[Symbol.toPrimitive] = function(hint) {
  // вот код для преобразования этого объекта в примитив
  // он должен вернуть примитивное значение
  // hint = чему-то из "string", "number", "default"
};

let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500


// Если нет Symbol.toPrimitive, тогда JavaScript пытается найти методы toString и valueOf:

// Для хинта "string": вызвать метод toString, 
// а если он не существует или возвращает объект вместо примитивного значения, 
// то valueOf (таким образом, toString имеет приоритет при строковом преобразовании).

// Для других хинтов: вызвать метод valueOf, 
// а если он не существует или возвращает объект вместо примитивного значения, 
// то toString (таким образом, valueOf имеет приоритет для математических операций).

let user1 = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500